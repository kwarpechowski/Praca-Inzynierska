\newpage
\section{Aplikacja mobilna - kontroler}

\begin{center}
\includegraphics[width=1\textwidth]{images/button_mockup.png}
\captionof{figure}{
Makieta - układ przycisków
}
\end{center}
\paragraph{}
Głównym założeniem było stworzenie uniwersalnego kontrolera przygotowanego pod dowolny rodzaj gry, bądź innej wizualizacji stworzonej w środowisku Unity. Podczas uruchomienia kontrolera serwer wysyła statusy przycisków oraz pól tekstowych.


\begin{center}
\includegraphics[width=1\textwidth]{images/graph1.png}

\includegraphics[width=1\textwidth]{images/graph2.png}
\captionof{figure}{
Przykładowa wizualizacja kontrolera
}
\end{center}

\subsection{Przyciski}
\paragraph{}
Każdy przycisk może zostać skonfigurowany poprez ustawienie tekstu. Dodatkowo można zablokować przycisk podczas gdy nie jest on potrzebny w danym czasie. 
Jednym z główny założeń architektonicznych był rozdzielenie warstwy widoku od logiki biznesowej. Ustalono, że stworzenie nowego przycisku odbywać się będzie wymagało tylko dodania definicji w warstwie widoku (plik layout w formacie XML).

\begin{lstlisting}[language=XML]
<pl.pjatk.remotecontroller.CustomButton
    app:name="button2"
    android:layout_gravity="center_horizontal"
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
/>
\end{lstlisting}
\captionof{lstlisting}{
	Przykład zdefiniowanego przycisku
}
\paragraph{}
Na potrzeby realizacji powyższego założenia stworzono klasę CustomButton, która jest rozszerzeniem (dziedziczy bezpośrednio) klasy Button znajdującej się w pakiecie  android.widget.
\paragraph{}
Każdy z przycisków musi posiadać własną nazwę kodową, gdyż serwer podczas komunikacji sieciowej identyfikuje przycisk poprzez unikalny klucz. Domyślnie w środowisku Android każdy komponent wizualny może posiadać swoje Id, jednakże jest one reprezentowane poprzez liczbę typu Integer.
Dla ułatwienia dalszego rozwoju aplikacji postanowiono stworzyć nowy atrybut. Ich definicje umieszczas ię w formacie XML w pliku attrs.xml

\begin{lstlisting}[language=XML]
<resources>
    <declare-styleable name="CustomButton">
        <attr name="name" format="string" />
    </declare-styleable>
</resources>
\end{lstlisting}
\captionof{lstlisting}{
    Definicja atrybutu o nazwie name
}

\paragraph{}
W konstuktorze poza domyślnymi wywołaniami klasy bazowej Button zapisywana jest wartość atrybutu name do zmiennej o tej nazwie oraz następuje wstępna konfiguracja przycisku.

\begin{lstlisting}[language=Java]
private static HashMap<String, CustomButton> buttons = new HashMap<String, CustomButton>();

private void setUp() {
    buttons.put(getName(), this);
    setText(getName());

    setOnClickListener(new View.OnClickListener(){
        @Override
        public void onClick(View v) {
            try {
                new Runner().execute(getName());
            } catch (Exception e) {
                Toast.makeText(getContext(), R.string.SendError, Toast.LENGTH_SHORT).show();
            }
        }
    });
}
\end{lstlisting}
\captionof{lstlisting}{
    Konfiguracja w klasie CustomButton
}
\paragraph{}
{\color{red}opisac co tu sie dzieje}


\subsection{Użycie styli}
\paragraph{}
Dodatkowym wymaganiem było umożliwienie szybkiej zmiany wyglądu przycisków w trakcie działania aplikacji. Użycie natywnych styli niestety nie jest możliwe bez ponownego renderowania widoku. Aby zaoszczędzić czas i moc obliczeniową postanowiono, iż zostatnie użyta technologia zmiany tła za pomocą metody backgroundResource. Różne wyglądy przycisku mogą być definiowane jako selectory (zewnętrzne pliki xml w katalogu drawable). Ważne, by plik był odpowiednio nazwany, gdyż po nazwie następuje wyszukiwanie schematu podczas zmiany wyglądu.

\begin{lstlisting}[language=Xml]
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true" >
        <shape>
            <gradient
                android:startColor="#bf1d00"
                android:endColor="#801300"
                android:angle="270" />
            <corners android:radius="10dp" />
            <stroke
                android:width="1dp"
                android:color="#71c2eb" />
        </shape>
    </item>
    <item>
        <shape xmlns:android="http://schemas.android.com/apk/res/android"
            android:shape="rectangle">
            <gradient android:startColor="#FFFFFF"
                android:endColor="#999"
                android:angle="270" />
        </shape>
    </item>
</selector>
\end{lstlisting}
\captionof{lstlisting}{
    Przykład zdefiniowanego tła
}
\paragraph{}
Wymaganiem była jednoczena zmiana wyglądu wszystkich przycisków. Rozwiązano to za pomocą metody statycznej, która iteruje po wszystkich przyciskach i wywołuje metdę backgroundResource.


\begin{lstlisting}[language=Java]
 public static void setLayout(int i) {
    for (CustomButton btn : buttons.values()) {
        btn.setBackgroundResource(i);
    }
}
\end{lstlisting}
\captionof{lstlisting}{
   Zmiana tła dla wszystkich przcisków
}


\begin{lstlisting}[language=Java]
CustomButton.setLayout(R.drawable.dark);
\end{lstlisting}
\captionof{lstlisting}{
   Przykład wywołania zmiany tła przycisków.
}



\subsection{Informacje tekstowe}
\paragraph{}
Pola tekstowe mogą mieć ustawioną dowolną treść w dowolnym czasie.

\subsection{Komunikacja sieciowa}
\paragraph{}
{\color{red}tutaj opisać implementacje warstwy komunikacyjnej}
